---
phase: 01-secure-foundation
plan: 04
type: execute
wave: 2
depends_on: ["01-03"]
files_modified: ["package.json", "supabase/schema.sql", "prisma/schema.prisma", "src/lib/supabase.ts", "src/app/api/profiles/route.ts"]
autonomous: true
user_setup:
  - service: supabase
    why: "Backend database and API for bot profile storage"
    env_vars:
      - name: NEXT_PUBLIC_SUPABASE_URL
        source: "Supabase Dashboard -> Project Settings -> API"
      - name: SUPABASE_SERVICE_ROLE_KEY
        source: "Supabase Dashboard -> Project Settings -> API -> service_role"
    dashboard_config:
      - task: "Create new Supabase project"
        location: "Supabase Dashboard"
      - task: "Run SQL schema migration"
        location: "Supabase SQL Editor"

must_haves:
  truths:
    - "Supabase database is properly configured for bot profile storage"
    - "API routes exist for profile CRUD operations"
    - "Database schema matches public bot configuration structure"
    - "Public read access is configured for profile viewing"
  artifacts:
    - path: "package.json"
      provides: "Supabase and Drizzle ORM dependencies"
      contains: "@supabase/supabase-js, drizzle-orm"
    - path: "prisma/schema.prisma"
      provides: "Database schema for bot profiles"
      min_lines: 20
    - path: "src/lib/supabase.ts"
      provides: "Supabase client configuration"
      min_lines: 15
    - path: "src/app/api/profiles/route.ts"
      provides: "API endpoints for profile operations"
      min_lines: 30
  key_links:
    - from: "src/app/api/profiles/route.ts"
      to: "prisma/schema.prisma"
      via: "Database operations using Prisma client"
      pattern: "prisma\\.botProfile\\."
    - from: "src/lib/supabase.ts"
      to: "package.json"
      via: "Environment variables and client initialization"
      pattern: "createClient"
    - from: "src/components/ProfileCard.tsx"
      to: "src/app/api/profiles/route.ts"
      via: "API data fetching for profile display"
      pattern: "fetch.*api/profiles"
---

<objective>
Configure Supabase backend integration for secure bot profile storage and public API access.

Purpose: Establish the database and API layer that stores bot profiles securely while providing public read access for profile viewing and sharing functionality.
Output: Working Supabase integration with database schema, API routes, and secure authentication for profile operations.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/ROADMAP.md
@.planning/phases/01-secure-foundation/01-DISCOVERY.md
@.planning/phases/01-secure-foundation/01-03-SUMMARY.md
@.planning/research/STACK.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure Supabase dependencies and database schema</name>
  <files>package.json, supabase/schema.sql, prisma/schema.prisma</files>
  <action>
  1. Update package.json to include Supabase dependencies:
     - @supabase/supabase-js@2 for client library
     - drizzle-orm@0.29.0 for type-safe database access
     - @supabase/auth-helpers for authentication helpers
     - Required Prisma dependencies for database management
  
  2. Create supabase/schema.sql with:
  
  ```sql
  -- Bot profiles table with JSONB for flexible configuration
  CREATE TABLE bot_profiles (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    name TEXT NOT NULL,
    slug TEXT UNIQUE NOT NULL,
    description TEXT NOT NULL,
    config JSONB NOT NULL,
    llm_primary TEXT NOT NULL,
    harness TEXT NOT NULL,
    skills TEXT[] DEFAULT '{}',
    mcps TEXT[] DEFAULT '{}',
    clis TEXT[] DEFAULT '{}',
    version TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- Full-text search capabilities
    search_vector tsvector GENERATED ALWAYS AS (
      setweight(to_tsvector('english', name), 'A') ||
      setweight(to_tsvector('english', description), 'B') ||
      setweight(to_tsvector('english', array_to_string(skills, ' ')), 'C')
    ) STORED
  );

  -- Enable RLS (Row Level Security)
  ALTER TABLE bot_profiles ENABLE ROW LEVEL SECURITY;

  -- Public read access (anyone can view profiles)
  CREATE POLICY "Public profiles are viewable by everyone" ON bot_profiles
    FOR SELECT USING (true);

  -- Insert access (for CLI tool uploads - will be secured with service role)
  CREATE POLICY "Service role can insert profiles" ON bot_profiles
    FOR INSERT WITH CHECK (true);

  -- Update access (service role only)
  CREATE POLICY "Service role can update profiles" ON bot_profiles
    FOR UPDATE USING (true);

  -- Create index for search
  CREATE INDEX bot_profiles_search_vector_idx ON bot_profiles USING GIN (search_vector);
  
  -- Create unique slug index
  CREATE INDEX bot_profiles_slug_idx ON bot_profiles (slug);
  ```

  3. Create prisma/schema.prisma with:
  
  ```prisma
  generator client {
    provider = "prisma-client-js"
  }

  datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
  }

  model BotProfile {
    id          String   @id @default(cuid())
    name        String
    slug        String   @unique
    description String
    config      Json
    llmPrimary  String   @map("llm_primary")
    harness     String
    skills      String[] @default([])
    mcps        String[] @default([])
    clis        String[] @default([])
    version     String
    createdAt   DateTime @default(now()) @map("created_at")
    updatedAt   DateTime @updatedAt

    @@map("bot_profiles")
  }
  ```
  
  4. Install dependencies and generate Prisma client
  
  From STACK.md research: Use Supabase 2.0+ with PostgreSQL 15+ and JSONB support for flexible bot configurations.
  </action>
  <verify>Prisma schema compiles successfully and matches Supabase SQL schema</verify>
  <done>Supabase dependencies installed and database schema configured for bot profile storage</done>
</task>

<task type="auto">
  <name>Task 2: Create Supabase client and API configuration</name>
  <files>src/lib/supabase.ts</files>
  <action>
  1. Create src/lib/supabase.ts with:
  
  ```typescript
  import { createClient } from '@supabase/supabase-js';

  // Public client (for web app - read-only access)
  export const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );

  // Service role client (for CLI and server operations - full access)
  export const supabaseAdmin = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    {
      auth: {
        autoRefreshToken: false,
        persistSession: false
      }
    }
  );

  // Database types for type safety
  export interface BotProfile {
    id: string;
    name: string;
    slug: string;
    description: string;
    config: any; // JSON from PublicBotConfig
    llm_primary: string;
    harness: string;
    skills: string[];
    mcps: string[];
    clis: string[];
    version: string;
    created_at: string;
    updated_at: string;
  }

  // Helper functions for database operations
  export async function createBotProfile(profile: any): Promise<BotProfile> {
    const { data, error } = await supabaseAdmin
      .from('bot_profiles')
      .insert({
        name: profile.name,
        slug: generateSlug(profile.name),
        description: profile.description,
        config: profile,
        llm_primary: profile.llm.primary,
        harness: profile.harness,
        skills: profile.skills,
        mcps: profile.mcps,
        clis: profile.clis,
        version: profile.version
      })
      .select()
      .single();

    if (error) throw error;
    return data;
  }

  export async function getBotProfile(slug: string): Promise<BotProfile | null> {
    const { data, error } = await supabase
      .from('bot_profiles')
      .select('*')
      .eq('slug', slug)
      .single();

    if (error) return null;
    return data;
  }

  export async function searchBotProfiles(query: string): Promise<BotProfile[]> {
    const { data, error } = await supabase
      .from('bot_profiles')
      .select('*')
      .textSearch('search_vector', query)
      .limit(20);

    if (error) throw error;
    return data || [];
  }

  // Generate unique slug from name
  function generateSlug(name: string): string {
    const baseSlug = name
      .toLowerCase()
      .replace(/[^a-z0-9]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');
    
    // Add random suffix for uniqueness
    const randomSuffix = Math.random().toString(36).substring(2, 8);
    return `${baseSlug}-${randomSuffix}`;
  }
  ```
  
  2. Add proper TypeScript types and error handling
  3. Include connection pooling and retry logic for production
  4. Add logging for debugging and monitoring
  
  From STACK.md research: Use Supabase client with Row Level Security and proper authentication patterns.
  </action>
  <verify>TypeScript compilation passes and Supabase client configuration is valid</verify>
  <done>Supabase client created with type-safe database operations and authentication handling</done>
</task>

<task type="auto">
  <name>Task 3: Implement API routes for profile operations</name>
  <files>src/app/api/profiles/route.ts</files>
  <action>
  1. Create src/app/api/profiles/route.ts with:
  
  ```typescript
  import { NextRequest, NextResponse } from 'next/server';
  import { createBotProfile, getBotProfile, searchBotProfiles } from '@/lib/supabase';
  import { PublicBotConfig } from '@/schemas/bot-config';
  import { z } from 'zod';

  // POST /api/profiles - Create new profile (for CLI tool)
  export async function POST(request: NextRequest) {
    try {
      const body = await request.json();
      
      // Validate against public schema
      const validatedConfig = PublicBotConfig.parse(body);
      
      // Create profile
      const profile = await createBotProfile(validatedConfig);
      
      return NextResponse.json({
        success: true,
        data: profile,
        message: 'Profile created successfully'
      });
      
    } catch (error) {
      if (error instanceof z.ZodError) {
        return NextResponse.json({
          success: false,
          error: 'Invalid configuration',
          details: error.errors
        }, { status: 400 });
      }
      
      console.error('Error creating profile:', error);
      return NextResponse.json({
        success: false,
        error: 'Failed to create profile'
      }, { status: 500 });
    }
  }

  // GET /api/profiles - List or search profiles
  export async function GET(request: NextRequest) {
    try {
      const { searchParams } = new URL(request.url);
      const query = searchParams.get('search');
      const slug = searchParams.get('slug');
      
      if (slug) {
        // Get specific profile
        const profile = await getBotProfile(slug);
        if (!profile) {
          return NextResponse.json({
            success: false,
            error: 'Profile not found'
          }, { status: 404 });
        }
        
        return NextResponse.json({
          success: true,
          data: profile
        });
      }
      
      if (query) {
        // Search profiles
        const profiles = await searchBotProfiles(query);
        return NextResponse.json({
          success: true,
          data: profiles
        });
      }
      
      // List recent profiles (default)
      const { supabase } = await import('@/lib/supabase');
      const { data: profiles } = await supabase
        .from('bot_profiles')
        .select('*')
        .order('created_at', { ascending: false })
        .limit(12);
      
      return NextResponse.json({
        success: true,
        data: profiles || []
      });
      
    } catch (error) {
      console.error('Error fetching profiles:', error);
      return NextResponse.json({
        success: false,
        error: 'Failed to fetch profiles'
      }, { status: 500 });
    }
  }

  // PUT /api/profiles - Update profile (if needed later)
  export async function PUT(request: NextRequest) {
    return NextResponse.json({
      success: false,
      error: 'Profile updates not implemented yet'
    }, { status: 501 });
  }
  ```
  
  2. Add proper error handling and validation
  3. Implement rate limiting considerations (supabase edge functions later)
  4. Add CORS headers for CLI tool access
  
  3. Create src/app/api/profiles/[slug]/route.ts for individual profile access:
  
  ```typescript
  import { NextRequest, NextResponse } from 'next/server';
  import { getBotProfile } from '@/lib/supabase';

  export async function GET(
    request: NextRequest,
    { params }: { params: { slug: string } }
  ) {
    try {
      const profile = await getBotProfile(params.slug);
      
      if (!profile) {
        return NextResponse.json({
          success: false,
          error: 'Profile not found'
        }, { status: 404 });
      }
      
      return NextResponse.json({
        success: true,
        data: profile
      });
      
    } catch (error) {
      console.error('Error fetching profile:', error);
      return NextResponse.json({
        success: false,
        error: 'Failed to fetch profile'
      }, { status: 500 });
    }
  }
  ```
  
  From STACK.md research: Use API Routes with proper validation, error handling, and security considerations.
  </action>
  <verify>API routes compile and handle different request methods correctly</verify>
  <done>API routes implemented for profile CRUD operations with proper validation and error handling</done>
</task>

</tasks>

<verification>
- Supabase database schema matches Prisma schema definitions
- API routes handle GET, POST requests correctly
- Profile creation validates against PublicBotConfig schema
- Public read access is properly configured via RLS policies
- TypeScript types are consistent across database layer
- Error handling is comprehensive and user-friendly
</verification>

<success_criteria>
- Supabase project is created and schema is applied
- API routes respond correctly to profile operations
- Database connection works with environment variables
- Row Level Security policies allow public read access
- Profile creation validates data and stores it correctly
- API can retrieve profiles by slug or search query
</success_criteria>

<output>
After completion, create `.planning/phases/01-secure-foundation/01-04-SUMMARY.md`
</output>