---
phase: 01-secure-foundation
plan: 04
type: execute
wave: 2
depends_on: ["01-03"]
files_modified: ["package.json", "convex/schema.ts", "convex/botProfiles.ts", "src/lib/convex.ts", "src/app/api/profiles/route.ts"]
autonomous: true
user_setup:
  - service: convex
    why: "Reactive backend database for bot profile storage with real-time subscriptions"
    env_vars:
      - name: NEXT_PUBLIC_CONVEX_URL
        source: "Convex Dashboard -> Project Settings -> Deployment URL"
      - name: CONVEX_DEPLOY_KEY
        source: "Convex Dashboard -> Project Settings -> Deploy Key (for CLI uploads)"
    dashboard_config:
      - task: "Create new Convex project"
        location: "Convex Dashboard (npx convex dev)"
      - task: "Deploy schema and functions"
        location: "Automatic on npx convex dev"

must_haves:
  truths:
    - "Convex database is properly configured for bot profile storage"
    - "Query and mutation functions exist for profile CRUD operations"
    - "Database schema matches public bot configuration structure"
    - "Reactive queries enable real-time profile updates on the web"
  artifacts:
    - path: "package.json"
      provides: "Convex dependencies"
      contains: "convex"
    - path: "convex/schema.ts"
      provides: "Database schema for bot profiles"
      min_lines: 15
    - path: "convex/botProfiles.ts"
      provides: "Query and mutation functions for profiles"
      min_lines: 40
    - path: "src/lib/convex.ts"
      provides: "Convex client configuration for Next.js"
      min_lines: 10
  key_links:
    - from: "src/app/api/profiles/route.ts"
      to: "convex/botProfiles.ts"
      via: "HTTP action calls to Convex mutations"
      pattern: "fetchMutation"
    - from: "convex/botProfiles.ts"
      to: "convex/schema.ts"
      via: "Schema types for bot profiles"
      pattern: "schema"
---

<objective>
Configure Convex backend integration for reactive bot profile storage with TypeScript-native queries.

Purpose: Establish the reactive database layer that stores bot profiles with automatic real-time subscriptions, enabling instant updates when new profiles are added without manual state management.

Output: Working Convex integration with TypeScript schema, query/mutation functions, and Next.js client setup for reactive profile operations.

**Why Convex over Supabase:**
- **Reactive by default:** Queries automatically update when data changes, perfect for a live bot showcase
- **TypeScript-native:** No SQL/ORM context switching, queries are just TypeScript functions
- **Zero boilerplate:** No connection management, no migrations, no RLS policies to configure
- **Automatic transactions:** Every mutation is ACID-compliant without begin/commit statements
- **AI-friendly:** LLMs can generate correct Convex code more reliably due to TypeScript-only patterns
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/ROADMAP.md
@.planning/phases/01-secure-foundation/01-DISCOVERY.md
@.planning/phases/01-secure-foundation/01-03-SUMMARY.md
@.planning/research/STACK.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Convex and initialize project</name>
  <files>package.json, convex/_generated</files>
  <action>
  1. Install Convex dependencies:
     ```bash
     npm install convex
     ```
  
  2. Initialize Convex project:
     ```bash
     npx convex init
     ```
     This creates:
     - `convex/` directory for server functions
     - `convex/_generated/` for type-safe API
     - `.env.local` with NEXT_PUBLIC_CONVEX_URL
  
  3. Update package.json scripts:
     ```json
     {
       "scripts": {
         "dev": "npm-run-all --parallel dev:frontend dev:backend",
         "dev:frontend": "next dev",
         "dev:backend": "convex dev"
       }
     }
     ```
  
  4. Run `npx convex dev` to start the development backend
  
  From STACK.md research: Convex provides reactive TypeScript-native queries with automatic transactions.
  </action>
  <verify>Convex development server starts and generates types successfully</verify>
  <done>Convex project initialized with development backend running</done>
</task>

<task type="auto">
  <name>Task 2: Define Convex schema for bot profiles</name>
  <files>convex/schema.ts</files>
  <action>
  1. Create convex/schema.ts with TypeScript schema:
  
  ```typescript
  import { defineSchema, defineTable } from "convex/server";
  import { v } from "convex/values";

  export default defineSchema({
    botProfiles: defineTable({
      // Core identity
      name: v.string(),
      slug: v.string(),
      description: v.string(), // "yearbook quote"
      
      // LLM configuration
      llmPrimary: v.string(),
      llmFallbacks: v.optional(v.array(v.string())),
      
      // Capabilities
      harness: v.string(),
      skills: v.array(v.string()),
      mcps: v.array(v.string()),
      clis: v.array(v.string()),
      version: v.string(),
      
      // Full config as JSON for flexibility
      config: v.any(),
    })
      .index("by_slug", ["slug"])
      .searchIndex("search_profiles", {
        searchField: "name",
        filterFields: ["harness", "llmPrimary"],
      }),
  });
  ```
  
  2. Deploy schema with `npx convex dev` (auto-deploys on save)
  
  Key differences from SQL:
  - No migrations to write or run
  - Indexes are TypeScript, not SQL
  - Search is built-in, not a separate extension
  - Schema changes deploy instantly in dev
  
  From Convex docs: Schema defines document types and indexes in TypeScript with automatic validation.
  </action>
  <verify>Schema deploys successfully and generates types in convex/_generated</verify>
  <done>Convex schema defined with proper indexes for slug lookup and full-text search</done>
</task>

<task type="auto">
  <name>Task 3: Create Convex query and mutation functions</name>
  <files>convex/botProfiles.ts</files>
  <action>
  1. Create convex/botProfiles.ts with query and mutation functions:
  
  ```typescript
  import { v } from "convex/values";
  import { query, mutation, action } from "./_generated/server";

  // Query: Get all profiles (reactive - auto-updates on changes)
  export const listProfiles = query({
    args: { limit: v.optional(v.number()) },
    handler: async (ctx, args) => {
      const profiles = await ctx.db
        .query("botProfiles")
        .order("desc")
        .take(args.limit ?? 12);
      return profiles;
    },
  });

  // Query: Get profile by slug (reactive)
  export const getBySlug = query({
    args: { slug: v.string() },
    handler: async (ctx, args) => {
      const profile = await ctx.db
        .query("botProfiles")
        .withIndex("by_slug", (q) => q.eq("slug", args.slug))
        .first();
      return profile;
    },
  });

  // Query: Search profiles
  export const searchProfiles = query({
    args: { searchQuery: v.string() },
    handler: async (ctx, args) => {
      const profiles = await ctx.db
        .query("botProfiles")
        .withSearchIndex("search_profiles", (q) =>
          q.search("name", args.searchQuery)
        )
        .take(20);
      return profiles;
    },
  });

  // Mutation: Create new profile (transaction - ACID compliant)
  export const createProfile = mutation({
    args: {
      name: v.string(),
      description: v.string(),
      llmPrimary: v.string(),
      llmFallbacks: v.optional(v.array(v.string())),
      harness: v.string(),
      skills: v.array(v.string()),
      mcps: v.array(v.string()),
      clis: v.array(v.string()),
      version: v.string(),
      config: v.any(),
    },
    handler: async (ctx, args) => {
      // Generate unique slug
      const baseSlug = args.name
        .toLowerCase()
        .replace(/[^a-z0-9]/g, "-")
        .replace(/-+/g, "-")
        .replace(/^-|-$/g, "");
      const randomSuffix = Math.random().toString(36).substring(2, 8);
      const slug = `${baseSlug}-${randomSuffix}`;

      // Insert profile (entire function is a transaction)
      const profileId = await ctx.db.insert("botProfiles", {
        name: args.name,
        slug,
        description: args.description,
        llmPrimary: args.llmPrimary,
        llmFallbacks: args.llmFallbacks,
        harness: args.harness,
        skills: args.skills,
        mcps: args.mcps,
        clis: args.clis,
        version: args.version,
        config: args.config,
      });

      // Return the created profile
      const profile = await ctx.db.get(profileId);
      return profile;
    },
  });

  // Mutation: Update profile
  export const updateProfile = mutation({
    args: {
      id: v.id("botProfiles"),
      description: v.optional(v.string()),
      config: v.optional(v.any()),
    },
    handler: async (ctx, args) => {
      const { id, ...updates } = args;
      await ctx.db.patch(id, updates);
      return await ctx.db.get(id);
    },
  });
  ```
  
  Key Convex patterns:
  - `query` functions are read-only and reactive (auto-re-run on data changes)
  - `mutation` functions are write operations, always transactional
  - No try/catch needed for transactions - Convex handles rollback automatically
  - All functions are fully typed via generated API
  
  From Convex docs: Query functions react to database changes; mutation functions run in transactions.
  </action>
  <verify>Functions deploy and generate correct TypeScript types in _generated/api</verify>
  <done>Convex functions created for listing, searching, and creating bot profiles</done>
</task>

<task type="auto">
  <name>Task 4: Set up Convex client in Next.js</name>
  <files>src/lib/convex.ts, src/app/providers.tsx</files>
  <action>
  1. Create src/lib/convex.ts with client configuration:
  
  ```typescript
  import { ConvexReactClient } from "convex/react";

  // Public client for web app (read access via queries)
  export const convex = new ConvexReactClient(
    process.env.NEXT_PUBLIC_CONVEX_URL!
  );
  ```
  
  2. Create src/app/providers.tsx for React context:
  
  ```typescript
  "use client";

  import { ConvexProvider } from "convex/react";
  import { convex } from "@/lib/convex";
  import { ReactNode } from "react";

  export function Providers({ children }: { children: ReactNode }) {
    return (
      <ConvexProvider client={convex}>
        {children}
      </ConvexProvider>
    );
  }
  ```
  
  3. Update src/app/layout.tsx to wrap with providers:
  
  ```typescript
  import { Providers } from "./providers";

  export default function RootLayout({
    children,
  }: {
    children: React.ReactNode;
  }) {
    return (
      <html lang="en">
        <body>
          <Providers>
            {children}
          </Providers>
        </body>
      </html>
    );
  }
  ```
  
  4. Usage in components is just like useState:
  
  ```typescript
  "use client";
  import { useQuery } from "convex/react";
  import { api } from "../../convex/_generated/api";

  export function ProfileList() {
    // This auto-updates when profiles change!
    const profiles = useQuery(api.botProfiles.listProfiles, { limit: 12 });
    
    if (profiles === undefined) return <div>Loading...</div>;
    
    return (
      <div>
        {profiles.map((profile) => (
          <ProfileCard key={profile._id} profile={profile} />
        ))}
      </div>
    );
  }
  ```
  
  From Convex docs: useQuery hook automatically subscribes to query results and updates React state.
  </action>
  <verify>Next.js app starts with ConvexProvider and queries work in components</verify>
  <done>Convex client configured with React context for reactive queries throughout the app</done>
</task>

<task type="auto">
  <name>Task 5: Create HTTP action for CLI uploads</name>
  <files>convex/http.ts, src/app/api/profiles/route.ts</files>
  <action>
  1. Create convex/http.ts for HTTP endpoints (CLI uploads):
  
  ```typescript
  import { httpRouter } from "convex/server";
  import { httpAction } from "./_generated/server";
  import { api } from "./_generated/api";

  const http = httpRouter();

  // POST /api/profiles - Create profile from CLI
  http.route({
    path: "/api/profiles",
    method: "POST",
    handler: httpAction(async (ctx, request) => {
      try {
        const body = await request.json();
        
        // Call the mutation to create profile
        const profile = await ctx.runMutation(api.botProfiles.createProfile, {
          name: body.name,
          description: body.description,
          llmPrimary: body.llm?.primary || body.llmPrimary,
          llmFallbacks: body.llm?.fallbacks || body.llmFallbacks,
          harness: body.harness,
          skills: body.skills || [],
          mcps: body.mcps || [],
          clis: body.clis || [],
          version: body.version,
          config: body,
        });

        return new Response(
          JSON.stringify({
            success: true,
            data: profile,
            message: "Profile created successfully",
          }),
          {
            status: 200,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*",
            },
          }
        );
      } catch (error) {
        console.error("Error creating profile:", error);
        return new Response(
          JSON.stringify({
            success: false,
            error: error instanceof Error ? error.message : "Failed to create profile",
          }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    }),
  });

  // GET /api/profiles/:slug - Get profile by slug
  http.route({
    path: "/api/profiles/{slug}",
    method: "GET",
    handler: httpAction(async (ctx, request) => {
      const url = new URL(request.url);
      const slug = url.pathname.split("/").pop();

      if (!slug) {
        return new Response(
          JSON.stringify({ success: false, error: "Slug required" }),
          { status: 400, headers: { "Content-Type": "application/json" } }
        );
      }

      const profile = await ctx.runQuery(api.botProfiles.getBySlug, { slug });

      if (!profile) {
        return new Response(
          JSON.stringify({ success: false, error: "Profile not found" }),
          { status: 404, headers: { "Content-Type": "application/json" } }
        );
      }

      return new Response(
        JSON.stringify({ success: true, data: profile }),
        {
          status: 200,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*",
          },
        }
      );
    }),
  });

  // CORS preflight
  http.route({
    path: "/api/profiles",
    method: "OPTIONS",
    handler: httpAction(async () => {
      return new Response(null, {
        status: 204,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type",
        },
      });
    }),
  });

  export default http;
  ```
  
  2. The Convex HTTP endpoints are automatically available at:
     - `https://<deployment>.convex.site/api/profiles` (POST for CLI)
     - `https://<deployment>.convex.site/api/profiles/{slug}` (GET)
  
  3. Update CLI to use Convex URL:
     - CLI reads CONVEX_URL from environment
     - Posts to `/api/profiles` endpoint
  
  Key differences from Next.js API routes:
  - HTTP actions run on Convex infrastructure (globally distributed)
  - Can call mutations directly (no REST -> DB translation)
  - CORS handled per-route
  
  From Convex docs: HTTP actions handle external API requests and can call queries/mutations directly.
  </action>
  <verify>HTTP endpoints deploy and respond to POST/GET requests correctly</verify>
  <done>HTTP action created for CLI profile uploads with proper CORS and error handling</done>
</task>

</tasks>

<verification>
- Convex development server runs and syncs schema
- Query functions return profiles correctly with reactive updates
- Mutation functions create profiles with proper validation
- HTTP actions handle CLI uploads and return profile data
- TypeScript types are generated and match schema
- useQuery in React components auto-updates when data changes

</verification>

<success_criteria>
- Convex project is created and development backend is running
- Schema defines bot profiles with indexes for slug and search
- Query functions enable reactive profile listing and lookup
- Mutation function creates profiles with unique slugs
- HTTP action accepts CLI uploads and creates profiles
- React components can use useQuery for auto-updating profile lists
- Full TypeScript type safety from schema to UI

</success_criteria>

<output>
After completion, create `.planning/phases/01-secure-foundation/01-04-SUMMARY.md`
</output>
