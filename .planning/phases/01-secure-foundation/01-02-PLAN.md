---
phase: 01-secure-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified: ["src/integrations/mcp.ts", "src/integrations/clawdbot.ts", "src/cli/commands/generate.ts"]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "CLI can securely query ClawdBot runtime for public configuration"
    - "MCP integration respects security boundaries and never accesses sensitive data"
    - "Configuration extraction uses RPC calls, not direct file access"
    - "All queries are validated against public schema before processing"
  artifacts:
    - path: "src/integrations/mcp.ts"
      provides: "MCP SDK wrapper for secure bot communication"
      min_lines: 40
    - path: "src/integrations/clawdbot.ts"
      provides: "ClawdBot-specific integration using MCP patterns"
      min_lines: 50
    - path: "src/cli/commands/generate.ts"
      provides: "Updated generate command with MCP integration"
      contains: "mcpIntegration call"
  key_links:
    - from: "src/cli/commands/generate.ts"
      to: "src/integrations/clawdbot.ts"
      via: "ClawdBot integration import and usage"
      pattern: "import.*ClawdBotIntegration"
    - from: "src/integrations/clawdbot.ts"
      to: "src/integrations/mcp.ts"
      via: "MCP wrapper for secure communication"
      pattern: "mcpWrapper\\."
    - from: "src/integrations/clawdbot.ts"
      to: "src/schemas/bot-config.ts"
      via: "Schema validation of extracted configuration"
      pattern: "PublicBotConfig\\.parse"
---

<objective>
Implement secure ClawdBot configuration extraction using MCP SDK with strict validation and security boundaries.

Purpose: Enable the CLI tool to safely query ClawdBot runtime for public configuration data without ever accessing raw files or sensitive information, following the "ask the bot" security pattern.
Output: Working MCP integration that extracts validated public bot configuration ready for profile generation.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/ROADMAP.md
@.planning/phases/01-secure-foundation/01-DISCOVERY.md
@.planning/phases/01-secure-foundation/01-01-SUMMARY.md
@.planning/research/STACK.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MCP integration wrapper with security patterns</name>
  <files>src/integrations/mcp.ts</files>
  <action>
  1. Create src/integrations/mcp.ts with MCP SDK wrapper:
  
  ```typescript
  import { Client } from '@modelcontext/sdk';
  import { z } from 'zod';

  export class MCPIntegration {
    private client: Client | null = null;
    private isConnected = false;

    // Initialize MCP connection with timeout
    async connect(timeoutMs = 10000): Promise<boolean> {
      try {
        // Connect to ClawdBot's MCP server
        this.client = new Client({
          name: 'botarena-cli',
          version: '1.0.0'
        });
        
        // Implement connection logic with timeout
        this.isConnected = true;
        return true;
      } catch (error) {
        console.error('MCP connection failed:', error);
        return false;
      }
    }

    // Secure query method with validation
    async queryTool(toolName: string, args: unknown, schema: z.ZodSchema): Promise<any> {
      if (!this.isConnected || !this.client) {
        throw new Error('MCP client not connected');
      }

      // Validate arguments before sending
      const validatedArgs = schema.parse(args);
      
      // Execute with timeout and retry logic
      const result = await this.client.call(toolName, validatedArgs);
      return result;
    }

    disconnect(): void {
      if (this.client) {
        this.client.close();
        this.isConnected = false;
      }
    }
  }
  ```
  
  2. Implement security patterns from DISCOVERY.md:
     - Gatekeeper pattern with strict argument validation
     - Timeout protection for all operations
     - Error handling with security logging
     - No sensitive data exposure in error messages
  
  3. Add connection retry logic and graceful degradation
  4. Implement audit logging for all MCP operations (timestamp, tool, args hash)
  
  From DISCOVERY.md: Use MCP SDK TypeScript with strict typing, timeout/retry logic, and audit logging.
  </action>
  <verify>TypeScript compilation passes and MCP wrapper class structure is valid</verify>
  <done>MCP integration wrapper created with security patterns and connection management</done>
</task>

<task type="auto">
  <name>Task 2: Implement ClawdBot-specific configuration extraction</name>
  <files>src/integrations/clawdbot.ts</files>
  <action>
  1. Create src/integrations/clawdbot.ts with ClawdBot integration:
  
  ```typescript
  import { MCPIntegration } from './mcp';
  import { PublicBotConfig, MCPResponse } from '../schemas/bot-config';
  import { z } from 'zod';

  export class ClawdBotIntegration {
    private mcp: MCPIntegration;

    constructor() {
      this.mcp = new MCPIntegration();
    }

    // Extract public configuration using "ask the bot" pattern
    async extractPublicConfig(): Promise<PublicBotConfig> {
      await this.mcp.connect();

      try {
        // Query ClawdBot runtime for public configuration
        const configData = await this.queryBotConfiguration();
        
        // Validate against public schema (security boundary)
        const publicConfig = PublicBotConfig.parse(configData);
        
        return publicConfig;
      } finally {
        this.mcp.disconnect();
      }
    }

    // Extract bot self-description (personality)
    async extractSelfDescription(): Promise<string> {
      await this.mcp.connect();

      try {
        // Query agent metadata for description
        const agentData = await this.queryAgentMetadata();
        
        // Fallback: ask bot to describe itself if no metadata
        if (!agentData.description) {
          return await this.generateSelfDescription();
        }
        
        return agentData.description;
      } finally {
        this.mcp.disconnect();
      }
    }

    private async queryBotConfiguration(): Promise<unknown> {
      const QuerySchema = z.object({
        include: z.array(z.string()).default(['public'])
      });

      // Use MCP to query ClawdBot's gateway for public config
      const result = await this.mcp.queryTool(
        'gateway_call',
        { method: 'get_public_config', args: { include: ['public'] } },
        QuerySchema
      );

      return result.data;
    }

    private async queryAgentMetadata(): Promise<{description?: string}> {
      const MetadataSchema = z.object({
        section: z.literal('agents')
      });

      const result = await this.mcp.queryTool(
        'gateway_call',
        { method: 'get_agent_config', args: { section: 'agents' } },
        MetadataSchema
      );

      return result.data || {};
    }

    private async generateSelfDescription(): Promise<string> {
      const PromptSchema = z.object({
        prompt: z.string(),
        max_length: z.number().default(500)
      });

      const result = await this.mcp.queryTool(
        'chat_with_assistant',
        { 
          prompt: 'Describe yourself in one sentence as if for a yearbook. Focus on your personality and capabilities without revealing sensitive information.',
          max_length: 500
        },
        PromptSchema
      );

      return result.data?.response || 'A helpful AI assistant';
    }
  }
  ```
  
  2. Implement security boundaries:
     - Only query public configuration endpoints
     - Never request API keys, tokens, or sensitive fields
     - Validate all responses against PublicBotConfig schema
     - Sanitize self-description to remove sensitive information
  
  3. Add comprehensive error handling:
     - Graceful fallback when MCP not available
     - Clear error messages for configuration issues
     - Security logging for failed queries
  
  From DISCOVERY.md: Use "ask the bot" pattern with RPC calls, never direct file access.
  </action>
  <verify>TypeScript compilation passes and all schema validations are properly implemented</verify>
  <done>ClawdBot integration implemented with secure configuration extraction and self-description capabilities</done>
</task>

<task type="auto">
  <name>Task 3: Integrate MCP functionality into CLI generate command</name>
  <files>src/cli/commands/generate.ts</files>
  <action>
  1. Update src/cli/commands/generate.ts to use ClawdBot integration:
  
  ```typescript
  import { Command, Flags } from '@oclif/core';
  import { ClawdBotIntegration } from '../../integrations/clawdbot';
  import { inquirer } from 'inquirer'; // For interactive prompts

  export default class Generate extends Command {
    static description = 'Generate a secure bot profile for BotArena';
    
    static flags = {
      interactive: Flags.boolean({
        char: 'i',
        description: 'Interactive mode with prompts',
        default: true
      }),
      'dry-run': Flags.boolean({
        description: 'Extract config without uploading',
        default: false
      })
    };

    async run(): Promise<void> {
      const { flags } = this;
      
      try {
        // Initialize integration
        const botIntegration = new ClawdBotIntegration();
        
        // Show progress
        this.log('üîç Discovering bot configuration...');
        
        // Extract public configuration
        const publicConfig = await botIntegration.extractPublicConfig();
        this.log(`‚úÖ Found bot: ${publicConfig.name}`);
        
        // Extract self-description if interactive
        if (flags.interactive) {
          this.log('üìù Extracting bot personality...');
          const description = await botIntegration.extractSelfDescription();
          publicConfig.description = description;
        }
        
        // Display extracted configuration
        this.displayConfig(publicConfig);
        
        if (!flags['dry-run']) {
          // TODO: Upload to Convex in next plan
          this.log('üöÄ Profile generation complete!');
          this.log('üì§ Ready to upload to BotArena (next plan)');
        } else {
          this.log('üîç Dry run complete - configuration validated');
        }
        
      } catch (error) {
        this.error(`‚ùå Failed to generate profile: ${error.message}`);
      }
    }

    private displayConfig(config: any): void {
      this.log('\nüìä Extracted Configuration:');
      this.log(`Name: ${config.name}`);
      this.log(`LLM: ${config.llm.primary}`);
      this.log(`Skills: ${config.skills.join(', ')}`);
      this.log(`Description: ${config.description}`);
    }
  }
  ```
  
  2. Add inquirer.js for interactive prompts (if not already installed)
  3. Implement proper progress indicators and user feedback
  4. Add comprehensive error handling with user-friendly messages
  
  3. Update package.json if needed to include inquirer dependency
  
  From DISCOVERY.md: Use interactive prompts, progress indicators, and clear error messages for better UX.
  </action>
  <verify>CLI command compiles and integrates with ClawdBot extraction functionality</verify>
  <done>Generate command updated with full MCP integration and user-friendly interface</done>
</task>

</tasks>

<verification>
- MCP integration connects to ClawdBot runtime successfully
- Configuration extraction returns only public fields
- Self-description extraction works with fallback mechanism  
- All responses validate against PublicBotConfig schema
- CLI provides clear progress feedback and error messages
- No sensitive configuration data is accessed or exposed
</verification>

<success_criteria>
- `npx botarena generate` command successfully extracts public bot configuration
- CLI never accesses raw configuration files (security verification)
- Extracted configuration validates against public schema only
- Bot self-description extraction works with interactive prompts
- Error handling is comprehensive and user-friendly
- All MCP operations include timeout and retry logic
</success_criteria>

<output>
After completion, create `.planning/phases/01-secure-foundation/01-02-SUMMARY.md`
</output>