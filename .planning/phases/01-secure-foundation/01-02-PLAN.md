---
phase: 01-secure-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified: ["src/lib/discovery.ts", "src/lib/clawdbot.ts", "src/cli/commands/generate.ts"]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "CLI discovers bot configuration by reading safe files (SOUL.md, skills, etc.)"
    - "File discovery respects security boundaries and never accesses sensitive files"
    - "Interactive prompts collect public info from user, not raw config files"
    - "All data is validated against public schema before processing"
  artifacts:
    - path: "src/lib/discovery.ts"
      provides: "File discovery for bot runtime detection"
      min_lines: 40
    - path: "src/lib/clawdbot.ts"
      provides: "ClawdBot-specific file discovery integration"
      min_lines: 50
    - path: "src/cli/commands/generate.ts"
      provides: "Updated generate command with file discovery"
      contains: "discoverBot call"
  key_links:
    - from: "src/cli/commands/generate.ts"
      to: "src/lib/clawdbot.ts"
      via: "ClawdBot discovery import and usage"
      pattern: "import.*ClawdBotDiscovery"
    - from: "src/lib/clawdbot.ts"
      to: "src/lib/discovery.ts"
      via: "File discovery utilities"
      pattern: "discover.*files"
    - from: "src/lib/clawdbot.ts"
      to: "src/schemas/bot-config.ts"
      via: "Schema validation of discovered configuration"
      pattern: "PublicBotConfig\\.parse"
---

<objective>
Implement secure ClawdBot configuration discovery using file reading and interactive prompts with strict validation.

Purpose: Enable the CLI tool to safely discover bot configuration by reading public files (SOUL.md, skills directory) and prompting the user for description, without ever accessing sensitive configuration files or API keys.
Output: Working file discovery that extracts validated public bot configuration ready for profile generation.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/ROADMAP.md
@.planning/phases/01-secure-foundation/01-DISCOVERY.md
@.planning/phases/01-secure-foundation/01-01-SUMMARY.md
@.planning/research/STACK.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create file discovery utilities</name>
  <files>src/lib/discovery.ts</files>
  <action>
  1. Create src/lib/discovery.ts with file discovery utilities:
  
  ```typescript
  import { z } from 'zod';
  import * as fs from 'fs/promises';
  import * as path from 'path';

  export interface DiscoveredFile {
    path: string;
    content: string;
    type: 'markdown' | 'json' | 'yaml' | 'text';
  }

  export interface DiscoveryResult {
    runtime: string;
    detectedFrom: string;
    files: DiscoveredFile[];
    name?: string;
    avatar?: string;
    skills?: string[];
  }

  // Safely read a file if it exists
  export async function safeReadFile(filePath: string): Promise<string | null> {
    try {
      return await fs.readFile(filePath, 'utf-8');
    } catch {
      return null;
    }
  }

  // Discover files in a directory matching patterns
  export async function discoverFiles(
    basePath: string, 
    patterns: string[]
  ): Promise<string[]> {
    const results: string[] = [];
    
    for (const pattern of patterns) {
      const fullPath = path.join(basePath, pattern);
      try {
        const stat = await fs.stat(fullPath);
        if (stat.isFile()) {
          results.push(fullPath);
        } else if (stat.isDirectory()) {
          const entries = await fs.readdir(fullPath);
          results.push(...entries.map(e => path.join(fullPath, e)));
        }
      } catch {
        // Path doesn't exist, skip silently
      }
    }
    
    return results;
  }

  // Parse markdown frontmatter
  export function parseFrontmatter(content: string): Record<string, string> {
    const match = content.match(/^---\n([\s\S]*?)\n---/);
    if (!match) return {};
    
    const frontmatter: Record<string, string> = {};
    const lines = match[1].split('\n');
    
    for (const line of lines) {
      const [key, ...valueParts] = line.split(':');
      if (key && valueParts.length > 0) {
        frontmatter[key.trim()] = valueParts.join(':').trim();
      }
    }
    
    return frontmatter;
  }

  // Extract name from SOUL.md content
  export function extractNameFromSoul(content: string): string | undefined {
    const frontmatter = parseFrontmatter(content);
    if (frontmatter.name) return frontmatter.name;
    
    // Fallback: look for "Name:" in content
    const match = content.match(/Name:\s*(.+)/i);
    return match?.[1]?.trim();
  }

  // Extract avatar from SOUL.md content
  export function extractAvatarFromSoul(content: string): string | undefined {
    const frontmatter = parseFrontmatter(content);
    if (frontmatter.avatar) return frontmatter.avatar;
    
    // Fallback: look for "Avatar:" in content
    const match = content.match(/Avatar:\s*(.+)/i);
    return match?.[1]?.trim();
  }
  ```
  
  2. Implement security patterns:
     - Only read explicitly allowed files (SOUL.md, skills/, etc.)
     - Never read files containing secrets (.env, config.json, etc.)
     - Validate file paths to prevent directory traversal
     - Limit file size to prevent memory issues
  
  3. Add error handling with graceful degradation
  
  From DISCOVERY.md: Use file discovery with strict allowlists for safe files only.
  </action>
  <verify>TypeScript compilation passes and file discovery utilities are valid</verify>
  <done>File discovery utilities created with security patterns and path validation</done>
</task>

<task type="auto">
  <name>Task 2: Implement ClawdBot-specific file discovery</name>
  <files>src/lib/clawdbot.ts</files>
  <action>
  1. Create src/lib/clawdbot.ts with ClawdBot discovery:
  
  ```typescript
  import { safeReadFile, discoverFiles, DiscoveryResult, extractNameFromSoul, extractAvatarFromSoul } from './discovery';
  import { PublicBotConfig } from '../schemas/bot-config';
  import * as path from 'path';

  // Files we are allowed to read (public/safe files only)
  const ALLOWED_FILES = [
    'SOUL.md',
    'IDENTITY.md',
    'skills/**/SKILL.md',  // Skill documentation
  ];

  // Directories to scan for skills
  const SKILL_DIRECTORIES = [
    'skills',
    '.clawdbot/skills',
  ];

  export class ClawdBotDiscovery {
    private basePath: string;

    constructor(basePath: string = process.cwd()) {
      this.basePath = basePath;
    }

    // Discover ClawdBot configuration from safe files
    async discover(): Promise<DiscoveryResult> {
      const result: DiscoveryResult = {
        runtime: 'ClawdBot',
        detectedFrom: this.basePath,
        files: [],
        skills: []
      };

      // Read SOUL.md for identity
      const soulContent = await safeReadFile(path.join(this.basePath, 'SOUL.md'));
      if (soulContent) {
        result.name = extractNameFromSoul(soulContent);
        result.avatar = extractAvatarFromSoul(soulContent);
        result.files.push({
          path: 'SOUL.md',
          content: soulContent,
          type: 'markdown'
        });
      }

      // Discover skills from skills directory
      const skills = await this.discoverSkills();
      result.skills = skills;

      return result;
    }

    // Extract public configuration from discovered files
    async extractPublicConfig(userDescription?: string): Promise<PublicBotConfig> {
      const discovery = await this.discover();

      // Build public config from discovered files + user input
      const publicConfig: PublicBotConfig = {
        name: discovery.name || 'Unnamed Bot',
        description: userDescription || 'A helpful AI assistant',
        llm: {
          primary: 'Not specified',
          fallbacks: []
        },
        skills: discovery.skills || [],
        harness: 'ClawdBot',
        version: '1.0.0'
      };

      // Validate against schema
      return PublicBotConfig.parse(publicConfig);
    }

    private async discoverSkills(): Promise<string[]> {
      const skills: string[] = [];
      
      for (const skillDir of SKILL_DIRECTORIES) {
        const fullPath = path.join(this.basePath, skillDir);
        try {
          const entries = await discoverFiles(fullPath, ['*']);
          for (const entry of entries) {
            // Extract skill name from directory or file
            const skillName = path.basename(entry);
            if (!skillName.startsWith('.') && !skillName.includes('test')) {
              skills.push(skillName);
            }
          }
        } catch {
          // Directory doesn't exist, skip
        }
      }
      
      return [...new Set(skills)]; // Deduplicate
    }

    // Check if this directory contains a ClawdBot instance
    async isClawdBot(): Promise<boolean> {
      const soulExists = await safeReadFile(path.join(this.basePath, 'SOUL.md'));
      const hasSkillsDir = await safeReadFile(path.join(this.basePath, 'skills/github/SKILL.md'));
      return soulExists !== null || hasSkillsDir !== null;
    }
  }
  ```
  
  2. Implement security boundaries:
     - Only read from ALLOWED_FILES list
     - Never attempt to read configuration files containing secrets
     - Validate all extracted data against PublicBotConfig schema
     - User provides description interactively (not auto-extracted)
  
  3. Add comprehensive error handling:
     - Graceful fallback when files not found
     - Clear error messages for configuration issues
     - Logging for discovery attempts
  
  From DISCOVERY.md: Use "ask the bot" pattern by reading public files, never sensitive config.
  </action>
  <verify>TypeScript compilation passes and all schema validations are properly implemented</verify>
  <done>ClawdBot file discovery implemented with secure file reading and skill detection</done>
</task>

<task type="auto">
  <name>Task 3: Integrate file discovery into CLI generate command</name>
  <files>src/cli/commands/generate.ts</files>
  <action>
  1. Update src/cli/commands/generate.ts to use file discovery:
  
  ```typescript
  import { Command, Flags } from '@oclif/core';
  import { ClawdBotDiscovery } from '../../lib/clawdbot';
  import inquirer from 'inquirer';

  export default class Generate extends Command {
    static description = 'Generate a secure bot profile for BotArena';
    
    static flags = {
      interactive: Flags.boolean({
        char: 'i',
        description: 'Interactive mode with prompts',
        default: true
      }),
      'dry-run': Flags.boolean({
        description: 'Extract config without uploading',
        default: false
      }),
      path: Flags.string({
        char: 'p',
        description: 'Path to bot directory',
        default: '.'
      })
    };

    async run(): Promise<void> {
      const { flags } = this;
      
      try {
        // Initialize discovery
        const discovery = new ClawdBotDiscovery(flags.path);
        
        // Detect if this is a ClawdBot instance
        const isClawdBot = await discovery.isClawdBot();
        if (!isClawdBot) {
          this.warn('No ClawdBot instance detected. Run from a bot directory.');
          return;
        }
        
        // Show progress
        this.log('ðŸ” Discovering bot configuration...');
        
        // Discover bot info from files
        const discovered = await discovery.discover();
        this.log(`âœ… Found bot: ${discovered.name || 'Unnamed'}`);
        this.log(`ðŸ“¦ Runtime: ${discovered.runtime}`);
        this.log(`ðŸ› ï¸  Skills detected: ${discovered.skills?.length || 0}`);
        
        // Get user description interactively
        let userDescription = '';
        if (flags.interactive) {
          const answers = await inquirer.prompt([{
            type: 'input',
            name: 'description',
            message: 'Describe your bot (yearbook quote style):',
            default: 'A helpful AI assistant',
            validate: (input: string) => input.length > 0 && input.length <= 500
          }]);
          userDescription = answers.description;
        }
        
        // Build public configuration
        const publicConfig = await discovery.extractPublicConfig(userDescription);
        
        // Display extracted configuration
        this.displayConfig(publicConfig);
        
        // Confirm before upload
        if (!flags['dry-run'] && flags.interactive) {
          const { confirm } = await inquirer.prompt([{
            type: 'confirm',
            name: 'confirm',
            message: 'Publish this profile to BotArena?',
            default: true
          }]);
          
          if (confirm) {
            // TODO: Upload to Convex in next plan
            this.log('ðŸš€ Profile generation complete!');
            this.log('ðŸ“¤ Ready to upload to BotArena (next plan)');
          } else {
            this.log('âŒ Cancelled');
          }
        } else if (flags['dry-run']) {
          this.log('ðŸ” Dry run complete - configuration validated');
        }
        
      } catch (error: any) {
        this.error(`âŒ Failed to generate profile: ${error.message}`);
      }
    }

    private displayConfig(config: any): void {
      this.log('\nðŸ“Š Public Configuration:');
      this.log(`Name: ${config.name}`);
      this.log(`Description: ${config.description}`);
      this.log(`Harness: ${config.harness}`);
      this.log(`Skills: ${config.skills?.join(', ') || 'None detected'}`);
    }
  }
  ```
  
  2. Add inquirer.js for interactive prompts
  3. Implement proper progress indicators and user feedback
  4. Add comprehensive error handling with user-friendly messages
  
  From DISCOVERY.md: Use interactive prompts, progress indicators, and clear error messages for better UX.
  </action>
  <verify>CLI command compiles and integrates with file discovery functionality</verify>
  <done>Generate command updated with file discovery and user-friendly interface</done>
</task>

</tasks>

<verification>
- File discovery reads only safe files (SOUL.md, skills)
- Configuration extraction returns only public fields
- Interactive prompts collect description from user
- All responses validate against PublicBotConfig schema
- CLI provides clear progress feedback and error messages
- No sensitive configuration files are accessed
</verification>

<success_criteria>
- `npx botarena generate` command successfully discovers bot from files
- CLI never accesses raw configuration files or secrets (security verification)
- Extracted configuration validates against public schema only
- User can provide custom description via interactive prompts
- Error handling is comprehensive and user-friendly
- File discovery handles missing files gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/01-secure-foundation/01-02-SUMMARY.md`
</output>
